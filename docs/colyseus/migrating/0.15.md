# Migrating to version 0.15 (from 0.14)

- [Schema callbacks API change](#schema-callbacks-api-slightly-changed)
- [Schema's `onChange` behaviour change](#schemas-onchange-behaviour-change)
- [MapSchema is now strict on property accessors](#mapschema-is-now-strict-on-property-accessors)
- [`client.reconnect()` API slightly changed]()
- [Built-in `client.auth` is gone! `@colyseus/social` fully deprecated](#built-in-client-auth-is-gone-colyseus-social-fully-deprecated)
- [`@colyseus/loadtest` has been reworked!](#colyseus-loadtest-has-been-reworked)
- [`@colyseus/command` typings update](#colyseus-command-typings-update)

---

## Schema callbacks API slightly changed

Now, instead of assigning a single callback per `onAdd`/`onChange`/`onRemove`, you attach them by calling as a method instead. You can attach more than one callback this way.

See example below:

```typescript fct_label="TypeScript"
// 0.14 (old)
state.players.onAdd = function(value, key) {/* do stuff */};
state.players.onChange = function(value, key) {/* do stuff */};
state.players.onRemove = function(value, key) {/* do stuff */};

// 0.15 (new)
state.players.onAdd(function(value, key) {/* do stuff */});
state.players.onChange(function(value, key) {/* do stuff */});
state.players.onRemove(function(value, key) {/* do stuff */});
```

```csharp fct_label="C#"
// 0.14 (old)
state.players.OnAdd += (key, value) => {/* do stuff */};
state.players.OnChange += (key, value) => {/* do stuff */};
state.players.OnRemove += (key, value) => {/* do stuff */};

// 0.15 (new)
state.players.OnAdd((key, value) => {/* do stuff */})
state.players.OnChange((key, value) => {/* do stuff */})
state.players.OnRemove((key, value) => {/* do stuff */})
```

```lua fct_label="LUA"
-- 0.14 (old)
state.players.on_add = function(value, key) --[[ do stuff ]] end
state.players.on_change = function(value, key) --[[ do stuff ]] end
state.players.on_remove = function(value, key) --[[ do stuff ]] end

-- 0.15 (new)
-- ATTENTION: this is a method call. make sure to use `:` instead of `.` here.
state.players:on_add(function(value, key) --[[ do stuff ]] end)
state.players:on_change(function(value, key) --[[ do stuff ]] end)
state.players:on_remove(function(value, key) --[[ do stuff ]] end)
```

```haxe fct_label="Haxe"
// 0.14 (old)
state.players.onAdd = function(value, key) {/* do stuff */};
state.players.onChange = function(value, key) {/* do stuff */};
state.players.onRemove = function(value, key) {/* do stuff */};

// 0.15 (new)
state.players.onAdd(function(value, key) {/* do stuff */});
state.players.onChange(function(value, key) {/* do stuff */});
state.players.onRemove(function(value, key) {/* do stuff */});
```

The return value of `onAdd()`/`onChange()`/`onRemove()` is a function that can detach the callback that have been added.

```typescript fct_label="TypeScript"
const detachCallback = state.players.onAdd(function(value, key) {/* do stuff */});

// detaches the onAdd callback.
detachCallback();
```

```csharp fct_label="C#"
var detachCallback = state.players.OnAdd((key, value) => {/* do stuff */})

// detaches the onAdd callback.
detachCallback();
```

```lua fct_label="LUA"
local detach_callback = state.players:on_add(function(value, key) --[[ do stuff ]] end)

-- detaches the onAdd callback.
detach_callback();
```

```haxe fct_label="Haxe"
var detachCallback = state.players.onAdd(function(value, key) {/* do stuff */});

// detaches the onAdd callback.
detachCallback();
```

---

## Schema's `onChange` behaviour change

Previously, the `onChange` callback wouldn't be fired during `onAdd` and `onRemove` if attached to a collection of items (`MapSchema`, `ArraySchema`, etc).

Now, `onChange` is triggered alongside with `onAdd` and `onRemove`.

---

## `MapSchema` is now strict on property accessors

Only JavaScript/TypeScript is affected. If you use a client-side SDK other than JavaScript/TypeScript, no change is needed on the client-side for you.

```typescript
// 0.14 (old)
this.state.players[client.sessionId] = new Player();

// 0.15 (new)
this.state.players.set(client.sessionId, new Player());
```

> **Reasoning:** `MapSchema` used to be treated as a regular JavaScript object in the early days. Since version 0.14 `MapSchema` uses a real `Map` internally, with a "proxy" compatibility layer in order to avoid breaking existing projects. Now the "proxy" layer has been removed, improving the performance slightly.

---

## `client.reconnect()` API slightly changed

The previous reconnection implementation had a [security vulnerability](https://github.com/colyseus/colyseus/issues/354), although very unlikely to be explored, we had to update its implementation to make it secure.

```typescript
// 0.14 (old)
client.reconnect(cachedRoomId, cachedSessionId)

// 0.15 (new)
client.reconnect(cachedReconnectionToken)
```

Insterad of providing the previously active `room.roomId` and `room.sessionId` for reconnection, you only provide the `room.reconnectionToken` instead.

Reconnection tokens are unique and private for each client.

---

## Built-in `client.auth` is gone! `@colyseus/social` fully deprecated.

The [documentation has been discouraging the use of `@colyseus/social`](https://docs.colyseus.io/colyseus/tools/colyseus-social/) since version 0.14.

Now `@colyseus/social` has been officially deprecated. If you **really** rely on it please reach out to the devs on Discord on how to proceed if you still need to use it.

---

## `@colyseus/loadtest` has been reworked!

The loadtest tool has been reworked to allow for more complex scripting, so your loadtest scripts will need to be slightly rewritten, as the new format looks like this:

```typescript
import { Client, Room } from "colyseus.js";
import { Options } from "@colyseus/loadtest";

export async function main(options: Options) {
    const client = new Client(options.endpoint);
    const room: Room = await client.joinOrCreate(options.roomName, {/*
        your join options here...
    */});

    console.log("joined successfully!");

    room.onMessage("message-type", (payload) => {
        // logic
    });

    room.onStateChange((state) => {
        console.log("state change:", state);
    });

    room.onLeave((code) => {
        console.log("left");
    });
}
```

## `@colyseus/command` typings update

On latest version of `@colyseus/command` (`0.2.0`), instead of providing the state as a generic when extending the `Command`, you now provide your whole `Room` type:

```typescript
import { Command } from "@colyseus/command";

export class MyRoom extends Room<State> {
    // ...
}

export class MyCommand extends Command<MyRoom> {
    // ...
}
```
